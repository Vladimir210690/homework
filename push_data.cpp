#include <iostream>
#include <ctime>

using namespace std;

struct Node { // Структура типа ячейки списка
	int date;
	Node* next;
};

struct List { // Структура типа головы списка
	int size;
	Node* first;
};

void push_front(List* lst, int number) { //Функция добавления новой ячейки в начало списка
	Node* title = new Node; // Создаем новую динамическую структуру
	title->date = number; // Присваиваем в поле значения - указанное пользователем значение
	
	title->next = lst->first; // Новая ячейка указавает на первую ячейку списка или на нулевой указатель
	lst->first = title; // Голова списка указывает на новую ячейку
	lst->size++; // Увеличиваем счетчик количества ячеек
}


void push_back(List* lst, int number) // Функция для добавления ячейки в конец списка
{
	Node* node = new Node(); // Динамически создаем новую ячейку
	node->date = number; // Присваиваем полю значения указанное значение

	if (lst->first == nullptr) // Проверяем - если указатель головы является нулевым - то паросто записываем новую ячейку следующей
		lst->first = node;
	else {
		Node* ptr = lst->first; // Иначе создаем указатель типа ячейки и присваиваем ему указатель на первую ячейку

		while (ptr->next != nullptr) { //  Бегаем по списку пока не попадется нулевой указатель списка
			ptr = ptr->next; // При каждой итерации - присваиваем указателю следующую ячейку
		}
		ptr->next = node; // Найдя последнюю ячейку - присваиваем её указателю - новую ячейку
	}
}

void print(List* lst) { // Функция вывода списка ячеек
	Node* pntr = lst->first; // Создаем указатель на начало списка ячеек
	while (lst->first != nullptr) { // Пробегаем по всем ячейкам до тех пор - пока не дойдем до конца списка
		cout << pntr->date  << endl; // Выводим данные текущей ячейки
		pntr = pntr->next; // Переводим указатель на следующую ячейку
	}
}

int main() {
	srand(time(NULL));
	int norm = 5; // Переменная для определения количества заполненных ячеек
	List head; // Создаем обьект структуры головы списка
	head.size = 0; // По умолчанию у нас 0 ячеек в списке
	head.first = nullptr; // Указатель головы пока является нулевым
	
	for (int i = norm; i > 0; i--) { // Для разнообразия сделал итерацию с декрементом
		push_front(&head, rand() % 10); // Рандомно заполняем поле данных ячеек
	}
	push_back(&head, 18); // Проверяем на работоспособность функцию push_back
	push_back(&head, 15);
	print(&head); // Используя функцию вывода - выводим данные всех ячеек

	return 0;
}